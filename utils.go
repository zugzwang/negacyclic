package negacyclic

import (
	"math/big"
	"math/bits"
)

// L1Distance returns the distance between `p` and `y` with respect to the
// canonical norm, defined by the given primitive N-th complex root of unity.
func L1Distance(p, y []*big.Int) *big.Int {
	if len(p) != len(y) {
		panic("incompatible arguments to distance")
	}
	diff := make([]*big.Int, len(p))
	for i := range p {
		diff[i] = new(big.Int).Sub(p[i], y[i])
	}

	return L1Norm(diff)
}

// L1Norm returns the l-1 norm of the vector formed by the evaluations of
// the given polynomial at the set of given primitive root of unity generated
// by `root`. Equivalently, it is the l-âˆž norm of the action of the Vandermonde map
// of these roots, on the given polynomial.
func L1Norm(pol []*big.Int) *big.Int {
	res := big.NewInt(0)
	aux := new(big.Int)
	for _, coeff := range pol {
		aux.Abs(coeff)
		res.Add(res, aux)
	}
	return res
}

// FindPrimitiveRootOfUnity returns the first n-th root of unity modulo q. It
// expects q = 1 mod n.
func FindPrimitiveRootOfUnity(n int, q *big.Int) *big.Int {
	if !q.ProbablyPrime(32) {
		panic("expects prime modulus")
	}
	if !isPowerOfTwo(n) {
		panic("expects `n` to be a power of two")
	}
	one := big.NewInt(1)
	if one.Mod(q, big.NewInt(int64(n))).Cmp(one) != 0 {
		panic("expects `q = 1 mod n`")
	}
	one = big.NewInt(1)
	exp := new(big.Int)
	exp.Sub(q, one)
	exp.Div(exp, big.NewInt(int64(n))) // exp = (q-1)/n
	counter := big.NewInt(1)
	g, aux := new(big.Int), new(big.Int)
	for {
		counter.Add(counter, one)
		if counter.Cmp(q) > 0 {
			panic("Not found")
		}
		g.Exp(counter, exp, q) // g = x ^{(q-1)/n}
		aux.Exp(g, big.NewInt(int64(n/2)), q)
		if aux.Cmp(one) != 0 {
			return g
		}
	}
}

// Returns true iff x is a power of two.
func isPowerOfTwo(x int) bool {
	return (x != 0) && ((x & (x - 1)) == 0)
}

// modularInverse computes the multiplicative inverse of `a` modulo q for a
// prime q.
func modularInverse(a, q *big.Int) *big.Int {
	if !q.ProbablyPrime(32) {
		panic("modular inverse implemented only for prime moduli")
	}
	// Euler's theorem: a^{q-1} = 1 mod q, i.e. a^{q-2} = a^{-1} mod q.
	aInv, exp := new(big.Int), new(big.Int)
	exp.Sub(q, big.NewInt(2))
	aInv.Exp(a, exp, q)
	return aInv
}

// rootsOfUnityBitReverse computes a slice of all roots of unity generated by
// a primitive root of unity modulo q, such that g^i is stored at the index
// obtained by reversing the bits of i. It is assumed that `g` is primitive, so
// that the slice is of the expected length.
func rootsOfUnityBitReverse(n int, g, q *big.Int) []*big.Int {
	result := make([]*big.Int, n)
	result[0] = big.NewInt(1)
	currentRoot := big.NewInt(1)
	for i := 1; i < n; i++ {
		index := reverseBits(i, n)
		result[index] = new(big.Int)
		result[index].Mul(currentRoot, g)
		result[index].Mod(result[index], q)
		currentRoot.Set(result[index])
	}
	return result
}

// reverseBits returns the integer formed by the bits of x in reverse order,
// and counting only the leftmost len(n) bits. It expects n to be a power of 2.
// This assumes a 64-bits system.
func reverseBits(x, n int) uint {
	rev := bits.Reverse(uint(x))
	ret := rev >> uint(65-bits.Len(uint(n)))
	return ret
}

//
// Internal
//

func addSlices(p, q []*big.Int) []*big.Int {
	if len(p) != len(q) {
		panic("incompatible addition")
	}
	result := make([]*big.Int, len(p))

	for i := range result {
		result[i] = new(big.Int)
		result[i].Add(p[i], q[i])
	}
	return result
}

func subSlices(p, q []*big.Int) []*big.Int {
	if len(p) != len(q) {
		panic("incompatible subtraction")
	}
	result := make([]*big.Int, len(p))

	for i := range result {
		result[i] = new(big.Int)
		result[i].Sub(p[i], q[i])
	}
	return result
}
